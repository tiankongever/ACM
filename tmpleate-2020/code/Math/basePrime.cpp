/*************************************************************************
> File Name: basePrime.cpp
> Author: tiankonguse
> Mail: i@tiankonguse.com 
> Created Time: Sat 26 Apr 2014 06:47:43 PM CST
***********************************************************************/

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<cmath>
#include<stack>
#include<algorithm>
#include<functional>
#include<stdarg.h>
using namespace std;
#ifdef __int64
typedef __int64 LL;
#else
typedef long long LL;
#endif

void setZero(char*a, int pos){
    a[pos>>3] &= ~(1<<(pos%8));
}

bool getIsZero(char*a, int pos){
    return a[pos>>3] & (1<<(pos%8));
}

/*
 * 问题：求小的n的素数的精确个数
 * (也可以把素数表保存下来或者快速判断一个数是不是素数)。
 * 素数：因子只有1和本身的数。
 * 基本方法：
 *  1. 从1开始，一个一个的判断这个数除了1和本身是否还有其它因子。
 *  2. 判断一个数n是不是素数，只需要判断出从2到n-1都不是n的因子即可。
 *  3. 复杂度: O(n^2)
 *  4. 正确性分析：这个算法是从上面素数的定义找的，所以正确性可以保证。
 *  5. 复杂度分析： 每个数需要判断是不是素数，判断一个数n是不是素数需要至少O(n)次。所以综合复杂度是 O(n^2)
 *
 * 正向优化.
 * 1. 从1开始，一个一个的判断这个数除了1和本身是否还有其它因子。
 * 2. 判断一个数 n 是不是素数， 只需要判断小于n的素数是不是n的因子即可。
 * 3. 复杂度： O(n^2/log(n))
 * 4. 正确性分析： 判断一个数n是不是素数时，我们只考虑小于n的素数。因为假设一个合数m是n的因子，则m的一个素因子一定也是n的因子，所以正确性可以保证
 * 5. 复杂度分析： 判断一个数n是不是素数时，我们只判断了小于n的素数的个数 pi(n)次，而pi(n) = O(n/log(n)), 故复杂度为 O(n^2/log(n))
 *
 * 逆向优化
 * 1. 把所有数字标记为素数。
 * 2. 从2开始查找第一个被标记为素数的数字，记为找到的一个素数。
 * 3. 把这个找到的素数的所有公倍数(忽略自己)标记为非素数。
 * 4. 直到查找到最后一个。
 * 5. 估计复杂度： O(n log(n))
 * 6. 正确性分析： 当一个数字被标记为非素数时可以理解，找到因子了; 对于找到的第一个被标记为素数的数字为什么是素书呢? 其实也很好理解,可以看到真正的素数一定没有被标记为非素数,然后那些未标记的数一个也不是第一个数的因子，那自然小于第一个数的素数都不是这个数的因子，所以正确性可以保证。
 * 7. 估计复杂度分析: 
 *     首先非素数，我们O(1) 判断，所以对于非素数的复杂度是 O(n - n/log(n))
 *     对于素数m，我们会循环 这个素数的公倍数的个数次，我们可以简单的理解为 n/m 次。
 *     即 O(n/2 + n/3 + n/5 + n/7 + n/11 + ... + n/n) 
 *       =O(n ( 1/2 + 1/3 + 1/7 + 1/11 + ... 1/n)) 
 *       =O(n log(n)) (证明暂时略，过几天补上)
 *    所以综合复杂度就是 O(n - n/log(n) + n log(n)) = O(n log(n))
 * 8. 精确复杂度: O(n log log(n))
 * 9. 精确复杂度分析： 实际上 O( 1/2 + 1/3 + 1/7 + 1/11 + .. + 1/n) = O(log log(n)),所以精确复杂度就是证明了。
 *
 * 再次逆向优化
 *  1. 在逆向优化的第三步，我们假设找到的素数是x, 我们可以从 x^2 开始标记非素数。
 *  2. 分析为什么: x的公倍数有 x*2, x*3, ..., x*(x-1) , x*x , ... 显然小于 x*x 的公倍数已经被标记为非素数了。
 *  3. 对于x*x 之后，每次应该加多少呢？ x 是奇数， x*x 也是奇数， 那么 x*x +x 一定是偶数，所以我们只需要每次家 2*x 即可。
 *  4. 对于 x*x 之后，我们是把 x*x + 2*k*x 标记为非素数，显然还是重复标记了好多数字。
 *  5. 那我们应该标记哪些数字呢？那我们就需要知道这次要标记的数字中哪些已经标记过，哪些未标记过。
 *  6. 这次我们准备标记的有 x*x, x*(x+2), x*(x+4) ..., 这个确实不好找到突破点，所以我们需要换种思路了。
 *  
 * 新思路
 * 1. 我们假设已经找到了k个素数。现在该对i操作了。
 * 2. i与这k个素数的乘积所的得到的数字都一定不是素数，所以我们标记了。
 * 3. 此时，我们找到的下一个未标记的一定是素数。
 * 4. 为什么呢？ 假设找到的下一个未标记的是m，但不是素数，则m有一个最小素因子k,以及另一个因子h(h=m/k, h>=k),则我们在h的时候就会把m标记的。
 * 5. 复杂度： O(n ?)
 * 6. 复杂度分析： 小于 k的素数的个数是 k/log(k),所以复杂度就是 3/log(3) + 4/log(4) + 5/log(5) + ... + n/log(n) = O( ? )
 * 7. 这样我们可以做什么呢？ 我们假设当前循环的数字是m, 有n=m/log(m)个素数。
 * 8. 当m不是素数的时候，在m的第一个素因子之后，会发生什么事呢？
 * 9. 假设m的最小素因子是k, 则 k*m 会被标记。 由于 m%k==0, 所以k之后的下一个素因子k2*m = k2 * m/k * k ,所以 k2 * m 有会在 k2*m/k 是被标记一次。实际上 k 之后的所有素数和m的乘积都会被再次标记。
 * 10. 既然会被再次标记，这次就没必要标记了。
 * 11.会不会由于这次未标记，而导致下次找到的第一个未标记的数字不是素数呢？答案是不会的。还是假设有这样的数字，在第一次遇到这样的不准确的数字m时，我们找到它的最小素因子k，然后会发现在 m/k 的时候，一定会把这个数字标记了。
 * 12. 这个优化对复杂度影响多大呢？
 * 13. 实际复杂度: 每个数字实际上只循环到它的最小素因子。我们用函数 minPrime(n) 表示吧。 然后循环次数是小于最小素因子的素数的个数。
 * 14. 即 minPrime(n)/log( minPrime(n) ). 而minPrime(n) 我们是非常小的，我们可以粗略估计为 minPrime(n)/log( minPrime(n) ) = O(1) 吧。
 * 15. 则综合复杂度是 n 吧。
 * 
 *
 * 10数字毫秒级算法
 * 网上流传一个 THE MEISSEL-LEHMER METHOD 算法，可谓厉害。
 * 我跑了一下，10亿数量级的仅仅跑了不到200毫秒。
 *
 */


unsigned int prime(unsigned int max){
    unsigned int count = 0;	/* 返回count: 素数个数 */
    char *sieve = (char *) malloc(sizeof(char) * ((max>>3) + 1));
    if (sieve == NULL) {
		fprintf(stderr, "\ndynamic memory allocation failed\n");
		exit(EXIT_FAILURE);
	}
    memset(sieve, 0xFF,sizeof(sieve));
    setZero(sieve, 0);    
    setZero(sieve, 1);    

    return count;
}


int main() {
    

    return 0;
}
