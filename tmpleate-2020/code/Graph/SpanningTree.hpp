// 生成树相关的一些问题 By 猛犸也钻地 @ 2012.02.24

/* 度限制生成树 //
Q: 求一个最小生成树，其中V0连接的边不能超过K个或只能刚好K个
1. 去掉所有和V0连接的边，对每个连通分量求最小生成树
2. 如果除去点V0外共有T个连通分量，且T>K，无解
3. 于是现在有一个最小T度生成树，然后用dp[V]计算出该点到V0的路径上
   权值最大的边是多少，再枚举和V0连接的没有使用过的边，找出一条边
   使得用那条边替换已有的边，增加的权值最小，不停替换直到V0出度为K */

/* 次小生成树 //
Q: 求一个次小生成树，要求权值之和必须大于等于或严格大于其最小生成树
1. 求最小生成树
2. 找一个根然后dp，求出每个点往上走2^L能到达的祖先是谁，以及
   这段路径上的最大边和次大边(如果仅要求大于等于的话就不需要次大边)
3. 枚举没有使用过的边，利用上面得到的信息，在O(logN)时间内对每条边
   计算出其能够替换的已有的最大和次大边，然后找出最佳替换方式 */

/* 斯坦纳树 //
Q: 求一个包含指定的K个特殊点的最小生成树，其他点不一定在树中
1. 用dp[mask][x]记录树根在点x，mask所对应的特殊点集在树中的最小权值之和
2. 将dp[][]初始化为正无穷，只有dp[1<<i][Ai]被初始化为0，Ai为第i个特殊点
3. 先求出所有点对间最短路，然后枚举mask，依次做两种转移：
3.1. 枚举x和mask的子集sub，合并两棵子树
     dp[mask][x]=min(dp[mask][x],dp[sub][x]+dp[mask^sub][x])
3.2. 枚举x和y，计算结点从y移动到x的花费
     dp[mask][x]=min(dp[mask][x],dp[mask][y]+minDistance(y,x))
     在上面的转移中，也可以把这些点同时放到队列里，用spfa更新最短路 */

/* 生成树计数 //
Q: 给定一个无权的无向图G，求生成树的个数
1. 令矩阵D[][]为度数矩阵，其中D[i][i]为结点i的度，其他位置的值为0
2. 令矩阵A[][]为邻接矩阵，当结点i和j之间有x条边时，D[i][j]=D[j][i]=x
3. 令矩阵C=D-A，矩阵C'为矩阵C抽去第k行和第k列后的一个n-1阶的子矩阵
   其中k可以任意设定，构造完C'后，生成树的个数即为C'行列式的值 */
